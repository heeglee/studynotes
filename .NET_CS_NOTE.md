# 2. C# 언어

## C#

### 구성 요소

- @을 사용 시 keyword도 name으로 쓸 수 있다. (권장 X)
  - .NET의 언어독립성 때문.
  - ex) @readonly -> readonly로도, @readonly로도 참조 가능
- ///로 시작하는 comment: XML Documentation

## Namespace

- Namespace 중첩

  ```c#
  namespace A
  {
      namespace B
      {
          class Heeg
      }
  }
  
  // same as above
  namespace A.B
  {
  	class Heeg
  }
  
  // refer
  using A.B;
  ```

- Shortcut

  ```c#
  using HGLEE = TotalSoftBank.CATOS.Management.HeegeonLee;
  ```

## Basic I/O

- Output formatting

  ```c#
  { index, width : format }
  ```

- Reading key input

  ```c#
  public static ConsoleKeyInfo ReadKey([bool intercept]);
  ```

## Main Func

- **public static** void main(string[] args)
  - 외부에서 호출되며(생략 가능)
  - 객체 생성 이전에 호출된다.
  - int argc는 필요 없음: args.Length does the same.

# 3. 타입

## Value Type

### 내장형

- 정수형, 실수형, 논리형, 문자형

### 열거형

- User Definition Type: 사용자가 값의 종류를 정의

- 순서대로 0, 1, 2...의 값을 가짐; 특정 값 대입 가능

- 기본적으로 int; 타입을 따로 선언할 수 있음

  ```c#
  enum Origin : byte { East, East, West, South, North }	// Error
  enum Origin : byte { East = 1, West = 1, South, North }	// Available; East==West
  enum Origin : byte { East, West, Dong = East }			// Available
  ```

- 열거형 -> 정수형, 문자열: Casting 필요

  ```c#
  enum Origin { East, West, South, North }
  Origin Turn = Origin.South;			// South
  int value = (int) Turn;				// 2
  string name = Turn.toString();		// South
  ```

### 구조체

- Value Type; 작고 단순한 타입에 적합

- default 접근자는 private: 외부 공개하려면 public 선언해야 함

- 파생, 상속 불가능

  ```c#
  struct Book {
      public string Name;
      public int Price;
  }
  
  static void Main() {
      Book b;
      b.Name = "데이터베이스 시스템 개론";
      b.Price = "10000";
  }
  ```

- Class식으로 사용

  ```c#
  struct Book {
      public string Name;
      public int Price;
      public Book(string aName, int aPrice) {
          Name = aName;
          Price = aPrice;
      }
  }
  
  static void Main() {
      Book b = new Book(".NET 프로그래밍 정복", 30000);
  }
  ```



## Reference Type

### 배열

- Reference Type

- 배열의 선언

  ```c#
  int[] arr1d = new int[3];			// 1차원
  int[,] arr2d = new int[3,2];		// 2차원
  int[] arri = { 1, 2, 3, 4, 5 };		// 초기값, 크기 생략
  ```

- 배열 초기화는 최초 할당 때만 가능; 재초기화하려면 일일이 값을 대입해야 함...

- 배열의 메서드: System.Array

  | Methods          | Description                               |
  | ---------------- | ----------------------------------------- |
  | GetLength(n)     | n차원의 요소 갯수                         |
  | GetUpperBound(n) | n차원의 마지막 요소 index                 |
  | Length           | 배열 요소의 총 갯수                       |
  | Rank             | 배열의 차수??                             |
  | Sort             | 정렬; 일정 범위만 정렬할 수도 있음        |
  | Reverse          | 순서 뒤집기; 일정 범위만 뒤집을 수도 있음 |
  | BinarySearch     | 이진 검색; 배열 정렬 필요                 |
  | Clear            | 지정 범위 요소 삭제                       |

- 배열의 배열

  ```c#
  int[][] aar = new int[][]
  {
  	new int[] { 1, 2, 3, 4 },				// aar[0][0], aar[0][1], ...
  	new int[] { 5, 6 },
  	new int[] { 7, 8, 9, 10, 11, 12 }
  };
  ```

### 문자열

- Reference Type; 선언만 해도 null로 초기화

- [] 연산자로 개별 문자를 읽을 수 있음

- 문자열 앞에 @: 확장열 치환 없이 있는 그대로 표기

  ```c#
  string str1 = "C:\\data\\file.txt";
  string str2 = @"C:\data\file.txt";		// str1 == str2
  ```

- 문자열 변경 시마다 새로 할당된다.

### Class

- Reference Type
- Java의 Class와 동일.




## Value / Reference

### 차이점

- 선언 직후 사용
  - Value: O. 선언 즉시 스택에 생성
  - Reference: X. 선언에 의해 참조만 생성되며 실제 메모리가 할당되지 않음
- 기억 장소에서 제거되는 시기
  - Value: 소속 객체/메서드 등등 종료 시 파괴
  - Reference: 더 이상 참조하는 변수가 없을 때, Garbage Collector에 의해
- 변수의 대입연산(=)
  - Value: 같은 값의 새로운 별개의 변수
  - Reference: 같은 데이터를 참조하는 변수; 한 변수의 값이 바뀌면 다른 쪽도 바뀜
    - string은 예외
- 변수의 비교 방법(==)
  - Value: 기억된 데이터가 같은가
  - Reference: Heap 영역의 번지가 같은가
    - string은 예외

### Call by Value/Reference

- 변수의 형태와 상관없이 값/참조를 선택하는 방법
  - 값 인수: method가 return될 때 파괴
  - 참조 인수: `ref`를 붙임. 값이 아닌 참조자 전달; 초기화되지 않으면 error.
  - 출력용 인수: `out`을 붙임. 값을 담아 호출원으로 돌려보냄(return 이전)
  - 가변 인수: `params` - 변수의 배열을 전달
    - 한 메서드에 하나만, 마지막 위치에만
    - ex. string.Format(string format, **params object[] args**)

## 타입 변환

### 타입 변환

- 암시적 변환
- 명시적 변환: 변환할 타입을 () 안에 명시
- 강제적 변환: System.Convert

### checked

- 변수의 Overflow 체크

  ```c#
  int i = 123456;
  short s;
  checked					// 체크 무시하려면 unchecked.
  {
      s = (short) i;		// OverflowException
  }
  ```


### boxing

- Value type - Reference type 간 변환

  ```c#
  int i = 3;
  object box = i;			// boxing
  
  i = (int) box;			// unboxing
  ```





---



# 4. 기본 문법

## 제어문

### 조건문, 반복문, 선택문

- C#의 조건식은 반드시 bool형이어야 함

- for, while, do-while...

- foreach

  > foreach (`type` `var` in `arr[]`) {  };
  - 하나의 foreach로 다차원 배열도 순회 가능
  - Collection class에 사용 가능

- switch

  - 제어 변수로 문자열 사용 가능

  - 각 case마다 (내용이 존재하는 경우) break 또는 goto가 필수로 존재해야 함

  - goto: 다른 case 또는 default로 이동 가능

    > goto case 1;
    >
    > goto default;

### 연산자



# 5. 클래스

## 클래스 선언

### 분할 선언

- 클래스, 구조체, 인터페이스 등을 소스 파일 여러개에 분할 가능

  ```c#
  // A.cs
  public partial class Class1 {}
  
  // B.cs
  public partial class Class2 {}
  ```

  - 같은 namespace 소속이어야 함
  - 접근지정자 일치해야 함
  - Generic 인수 일치해야 함
  - 상속받는 부모 클래스는 하나여야 함; 한 쪽에만 상속하고 나머지는 생략 가능
  - 인터페이스 상속: 모든 조각이 병합됨
  - abstract, sealed 지정: 조각 상관 없이 한 번만 해도 됨(모든 조각에 지정해도 됨)
  - member 선언 순서, attribute 순서 등 정의되지 않음
    - 선언 순서가 중요한 언어에서 사용하는 경우 분할 선언하지 말아야 함
  - 클래스에 속한 내부 타입도 분할 선언 가능
    - 외부 타입도 partial 지정자 필수

### 지정자

- 접근지정자

  | Modifier           | Description                                 |
  | ------------------ | ------------------------------------------- |
  | private            | Class 내부에서만 접근 가능                  |
  | protected          | Class 내부 \|\| Child class에서만 접근 가능 |
  | public             | 외부에서 접근 가능                          |
  | internal           | Assembly 내에서만 접근 가능                 |
  | protected internal | Assembly \|\| Child class에서만 접근 가능   |

  - default는 private

### 생성자

- 생성자 overload

  ```c#
  class NormalClass
  {
      private int Alpha;
      private string Beta;
  
      public NormalClass(int a, string b)
      	: this(a)							// overloading
      {
      	Beta = b;
      }
  
      public NormalClass(int a)
      {
      	Alpha = a;
      }
  }
  ```

### 파괴자

- class 앞에 ~ 기호
- file stream, network connection, etc.
  - .NET Framework에 의해 관리되지 않는 자원
- 파괴자 호출 즉시 해제가 보장되는 건 아님



## Member

### static

- 개별 instance가 아닌, class에 소속
  - 메모리에 딱 하나만 생성, 모든 instance가 공유;
  - this가 없음; instance field 참조 불가, static field만 참조 가능
- static constructor
  - 정적 필드만 초기화
  - 인수와 접근지정자를 가지지 않음
  - 참조 타입의 정적 필드를 초기화하는 경우

### 상수

- const
  - 초기값 필요
  - 값 타입과 문자열만 가능
- readonly
  - 생성자에 의해 초기화됨; 생성되는 동안은 상수가 아님
  - 객체마다 다른 값을 가질 수 있음
  - 클래스의 필드에만 적용

### Nested Type

- 클래스에 포함된 내부 클래스, 구조체, 열거형, 델리게이트...
- ↔ Non-nested Type



# 6. 함수형 멤버

## Method

### Method Overloading

- 이름이 같고 Signature(인수의 갯수 및 타입)가 다른 methods.

- return type만 다른 overload는 불가능

  ```c#
  // Overload 불가
  void func(int a) {}
  int func(int a) {}
  double func(int a) {}
  ```

- ref/out에 의해 값/참조 타입이 바뀌는 경우는 가능

  ```c#
  // Overload 가능
  void func(int a) {}
  void func(ref int a) {}
  ```

- ref와 out만 다른 경우 불가

  ```c#
  // Overload 불가
  void func(ref int a) {}
  void func(out int a) {}
  ```



## Property

### Property

- Getter/Setter를 대체하는 필드 접근자

  ```c#
  // basic format
  {
      get { return value; }
      set { value = i; }
  }
  ```

- 코드를 가지는 **method**(field 아님); method가 할 수 있는 대부분의 능동적 동작 가능
  - 값을 get/set하면서 동시에 다른 코드 실행 가능
  - 읽기/쓰기 전용, 접근 권한 따로 지정 가능
  - Inline으로 처리; Get/Set보다 빠르게 동작함

### Indexer

- index를 이용해 객체를 배열처럼 사용하게 해 주는 method

  ```c#
  class NormalClass
  {
      public int this[idx]
      {
          get
          {
              switch(idx)
              {
              	// case A: return fieldA; ...
              }
          }
          set
          {
              switch(idx)
              {
                  // case A: fieldA = value;
              }
          }
      }
  }
  ```

- field 이름 대신 index로 특정 필드에 access: loop 용이, ..
- index의 타입 제한 X: 실수, 문자, 참조형 타입 모두 가능



## 연산자

### 연산자 오버로딩

- 연산자를 재정의해 *객체끼리 직접* 연산할 수 있도록 함

  - 메서드로 연산 기능을 구현할 수는 있으나 복잡해지므로

- 연산자 함수명: `operator X`

  - X 자리에 연산자
  - 클래스 간 연산, 클래스와 다른 타입과의 연산도 가능

  ```c#
  Class DT
  {
      private int iq;
      public DT() {}
      
      // 클래스 간 + 연산
      public static DT operator +(DT A, DT B)
      {
      	DT T = new DT();
      	T.iq = A.iq + B.iq;
      	
      	return T;
      }
      
      // 클래스와 int 간 + 연산
      // += 연산도 자동으로 정의됨
      // ++는 예외; 서로 다른 연산자임
      public static DT operator +(DT A, int b)
      {
      	DT T = new DT();
      	T.iq = A.iq + b;
      	
      	return T;
      }
      
      // 교환법칙
      public static DT operator +(int b, DT A)
      {
      	return A + b;
      }
  }
  ```

- 오버로딩 가능한 연산자

  | Category | Operator                      | 비고                               |
  | -------- | ----------------------------- | ---------------------------------- |
  | 산술     | +   -   *   /   %             |                                    |
  | 부호     | +   -                         |                                    |
  | 증감     | ++   --                       | 전위, 후위 구분 없음               |
  | 비트     | &   \|   ^   <<   >>   ~      |                                    |
  | 비교     | ==   !=   >   <   >=   <=   ! | bool 타입 반환, 반대 연산자도 정의 |

- 오버로딩 불가능한 연산자

  - =
  - []: indexer로 대신 정의
  - &&, ||

### 캐스트 연산자

> public static implicit(explicit) operator 변환대상(인수)

- 클래스를 클래스 또는 다른 타입으로 변환하는 방식 지정

  - implicit: 암시적. 컴파일러가 임의로 변환하는 것을 허가
  - explicit: 명시적. 캐스팅 필요

  ```c#
  class Time
  {
      public int min, sec;
      public Time();
      
      // implicit: int = Time;
      public static implicit operator int(Time T)
      {
          return T.min * 60 + T.sec;
      }
      
      // explicit: Time = (Time)int;
      public static explicit operator Time(int abs)
      {
          Time T = new Time();
          T.min = abs / 60;
          T.sec = abs % 60;
          
          return T;
      }
  }
  ```



# 7. 클래스 상속

## 상속/포함

### 상속

- *'is a'*

- 자바와의 문법 상 차이

  ```c#
  class Human
  {
      protected string name;
      public Human(string name)
      {
          this.name = name;
      }
      public virtual void Whois()			// 
      {
          Console.WriteLine("name: " + this.name);
      }
  }
  
  class Man : Human						// Class Man extends Human
  {
  	protected int age;
  	public Man(string name, int age)
  		: base(name)					// super(name)
      {
      	this.age = age;
      }
      public override void Whois()		// @Override
      {
          Console.WriteLine("name: {0}, age: {1}", name, age);
      }
  }
  
  class Program
  {
      static void Checker(Human H)
      {
          if (H is Man) { ... }			// typeof(H) == Man
      }
  }
  ```

### 포함

- 클래스가 다른 클래스의 객체를 내부에 선언; 내부에 선언한 객체의 기능을 사용
- *'has a'*

### 형 변환

- is: 타입 점검

- as: 안전한 형 변환

  ```c#
  Human H = new Human();
  Man M = H as Man;				// 변환 실패 시 return null
  ```

  - 값 타입에는 쓸 수 없음

## Override

- virtual: 부모 클래스의 함수에 붙임; 재정의 대상
- override: 자바의 @override - modifier 위치에 들어감



## 추상 클래스

### 추상 메서드/클래스

- abstract: 자바와 같음!

- virtual을 붙이지 않아도 가상으로 취급

### 봉인 메서드/클래스

- sealed
- 메서드 봉인 시, 이후 파생 클래스에서 재정의 불가: new로 새 메서드를 만들어야 함
- override 안전성 문제 / 라이선스 보호 / 보안 / 성능 / ...



# 8. 인터페이스

- 자바와 동일
  - 객체 생성 불가, 추상 메서드로 구성, 선언된 메서드의 구현 강제, ...
  - 인터페이스 간 상속: 다중 상속 가능
  - 타입이므로 변수/인수로 선언하거나 return될 수 있음



## 인터페이스 활용

